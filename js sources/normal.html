<meta name=viewport content=width=480,user-scalable=no>
<canvas width=480 height=640 style=background:black;margin:auto;display:block></canvas>
<script>

  const w = 480,
    h = 640,
    canvas = document.getElementsByTagName('canvas')[0],
    c = canvas.getContext("2d"),
    ra = Math.random,
    fl = Math.floor,
    pos = { x: w / 2, y: h / 2 },
    vel = { x: 0, y: 0 },

    arr = l => [...Array(l)],
    scr_a = (j, m, f) => ({x: f ? j[0] * w : w - j[0] * w, y: -j[1] * 10 + m * sc}),
    scr = (j, m) => ({x: j.x, y: j.y + m * sc}),

    ci = (x, y, r, o) => {
      c.beginPath()
      c.ellipse(x, y, r, r, .79, 0, 6.28)
      c.fill()

      c.beginPath()
      c.ellipse(x, y, r + 5, r + 5, .79, 0, 6.28)
      if (o) c.stroke()
    },
    draw = () => {
      c.clearRect(0, 0, w, h)

      c.lineWidth = 2;
      c.strokeStyle = '#FF4500';
      o.map(v => c.strokeRect(v.x - 5, v.y - 5 + sc, 10, 10))

      c.lineWidth = 1;
      c.strokeStyle = c.fillStyle = "#FFFFE0"
      ci(pos.x, pos.y, 10, 1)

      c.fillStyle = "#3CB371"
      b.map(v => ci(v.x, v.y + sc, 7))

      c.font = '30px Arial';
      c.fillText('' + score, 20, 40)

      ri = window.requestAnimationFrame(draw)
    },

    die = () => {
      clearInterval(phtmr)
      ri && (ri = window.cancelAnimationFrame(ri));
      c.fillStyle = 'red';
      c.textAlign = 'center';
      c.fillText('Game Over', w/2, h/2);
    },

    dist = (a, b, x = a.x - b.x, y = a.y - b.y) => Math.sqrt(x * x + y * y),

    phl = () => {
      pos.x += vel.x
      pos.y += vel.y
      vel.x *= 0.99
      vel.y += 0.1
      let ns = sc + speed + (pos.y < (h / 2) ? 3 - pos.y / (h / 6) : 0)
      if (speed < 4) speed += 0.001

      if (fl(sc / 300) !== fl(ns / 300)) spawn(~~(ra() * 9))
      sc = ns

      pos.y > h && die()

      o.map(v => dist(scr(v, 1), pos) < 23 && die());
      b = b.filter((bo) => dist(scr(bo, 1), pos) > 23 || (score++ && !1))
    },

    spawn = n => {
      let fl = ra() > .5
      chunks_o[n].map(i => o.push(scr_a(i, -1, fl)))
      chunks_b[n].map(i => b.push(scr_a(i, -1, fl)))
    },

    start = () => {
      draw();
      phtmr = setInterval(phl, 20)
      spawn(0)
    },

    chunks_o = [
      [
        [1 / 4, 0],
        [3 / 4, 0],
        [1 / 4, 3],
        [3 / 4, 3],
        [1 / 4, 6],
        [3 / 4, 6]
      ],
      [
        [.5, 0],
        [.5, 3],
        [.5, 6]
      ],
      [
        [1 / 4, 0],
        [   .5, 0],
        [3 / 4, 0]
      ],
      arr(8).map(x => [.1 + x * .1, x * 2]),
      arr(6).map(x => [.1 + x * .1, 0]),
      arr(5).map(x => [.25, x * 2]),
      arr(5).map(x => [1 / 6 + x / 6, 0]),
      arr(6).map(x => [1 / 3 + x / 15, 0]).concat(arr(6).map(x => [1 / 3 + x / 15, 18])),
      arr(16).map(x => [.06 + x / 17, ~~x % 4 * 4])
    ],
    chunks_b = [
      [
        [.5, 3]
      ],
      [
        [1 / 4, 3],
        [3 / 4, 3]
      ],
      [],
      [],
      [
        [.8, 0]
      ],
      [
        [.75, 5]
      ],
      arr(5).map(x => [1 / 6 + x / 6, 2]),
      arr(6).map(x => [1 / 3 + x / 15, 8]),
      [
        [.5, 6]
      ]
    ];

  let phtmr = null,
    o = [],
    b = [],
    sc = 0,
    score = 0,
    speed = 1,
    ri = 0;

  canvas.onmousedown = e => {
    let rect = canvas.getBoundingClientRect()
    vel.x = (e.clientX - rect.left) / w * 10 - 5
    vel.y = -5 * pos.y / h
    !ri && start()
  }
</script>
